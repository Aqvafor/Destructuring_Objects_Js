'use strict';

// Data needed for a later exercise
// ЗАкоментируем так как одни и теже переменные в двух файлах js,, а переменные изза того что они оба подключены одни 
const flights =
  '_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30';




// Data needed for first part of the section
// ЗАкоментируем так как одни и теже переменные в двух файлах js,, а переменные изза того что они оба подключены одни 
const restaurant = {
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto'],

  order: function (starterIndex, mainIndex) {
    // Здесь сама деструктуризация не происходит. Используе эту функцию внизу
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
  },

  openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0, // Open 24 hours
      close: 24,
    },
  },

  //Practical appliaction of this destructing Практическо приожения деструктуризации объекта
//для этого создадим еще один метод. Много раз в js у нас есть функции с кучей параметров. Но тогда будет довольно таки сложно узнать порядок параметров  , котоые используются в функции. И вместо определения параметров вручную, мы можем просто передать объект в функцию в качестве аргумента. И функция затем немедленно дестрактуризирует (распакуюет) этот объект

//Например напишем функцию поряокДоставки и сейчас просто передадим объект в качестве аргумента а затем в консоли привызове фукнции покажем его
//orderDelivery: function(obj){
//  console.log(obj);  
//}
// нО ТАКЖЕ МЫ МОЖЕМ РАСПОковать(деструктуризировать) прямо в аргумент функции 

//Получается что мы не передали 4 аргумента, а 1 параметр в качетсве объекта и получая объект мы немедленно распаковываем. И поэтому имена параметров {starterIndex, mainIndex, time, address} должны быть именно такими же, которые написанны в самом переданном объекте. Но замечательно то, что в саммо объекте свойства не должны совпадать с порядкомм , (параметра функции) в которую мы расспакавывем объект restaurant.orderDelivery 
// И это делает дествительно легко для использования функции указывать эти аргументы (time,address,mainIndex,starterIndex)

// Так же мы можем установить значения по умолчанию (starterIndex = 1 и т.д.), если у объекта не хватит аргументов

orderDelivery: function({starterIndex = 1, mainIndex = 0, time = '20:00', address}){
  console.log(`Order received ${this.mainMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`);  

//Теперь выведется сторока с переданами данными ниже и получится так 
// Order received undefined and Risotto will be delivered to Via del solo, 21 at 22:30
}

};

// Получим Order received Pasta and Pizza will be delivered to Via del solo, 21 at 20:00
restaurant.orderDelivery({ // Остальные два аргумента примут значения по дефолту starterIndex = 1, mainIndex = 0, так как объект был расспакован
  
  address: 'Via del solo, 21',
  startIndex: 2.
})

// Вызовем функцию orderDelivery у объекта retaraunt и передадим в качестве параметров объект параметров.И ЭТО ОЧЕНЬ ПОЛЕЗНО ДЛЯ БИБЛИОТЕК РАБОТАЮЩИХ С ДАННЫМИ ТРЕТИХ ЛИЦ
// Выведется объект который с помощью cl в написанном методе {time: '22:30', address: 'Via del solo, 21', mainIndex: 2, startIndex: 2}
restaurant.orderDelivery({
  time: '22:30',
  address: 'Via del solo, 21',
  mainIndex: 2,
  startIndex: 2.
})


// Destcruring Objects

// Для деструктуризации объектов мы используе {}потому что мы так и создаем объекты
// В отличие от массива нам необязательно сблюдать порядок написания свойств, так как это объект
const {
  name,
  openingHours,
  categories
} = restaurant; // Создадутся новые три переменные основанные на объекте ресторан 
console.log(name, openingHours, categories); // name - Classico Italiano,  openingHours - {thu: {…}, fri: {…}, sat: {…}}fri: {open: 11, close: 23}sat: {open: 0, close: 24}thu: {open: 12, close: 22}[[Prototype]]: Object , categoties -  (4) ['Italian', 'Pizzeria', 'Vegetarian', 'Organic']
// Это очень полезно , когда мы будем иметь дело с результаом API вызова, который в основном значи получение данных из другого web application(вэб приложения). такие как данне погоды, или данные о фильмах и т.д. 
// Эти данные обычно приходят в основном от объектов
// ПОЭТОМУ ДИСТРУКТУРИЗАЦИЯ(РАСПАКОВКА) ДЕСЙТВИТЕЛЬНО СПАСАЕТ. ЭТО ПОЗВОЛЯЕТ ПИСАТЬ НАМНОГО МЕНЬШЕ КОДА. ПОЭТОМУ ЭТО ДЕЙСТВИТЕЛЬНО ИСПОЛЬЗУЕТСЯ В СОВРЕМЕННЫХ ПРИЛОЖЕНИЯХ(APPLICATIONS) 




// нО ЧТО ЕСЛИ МЫ ХОТИМ ЧТОБЫ имена значений отличались от имен свойств
// Мы можем сделать в таком случае так 
// Кончено нам до сих пор нужна ссылка к имени свйоств, как мы делали это ранее. В противном случае(otherwise ) js не имеет возможности узнатьь, что мы действительно хотим. Поэтому напишем name снова и с помощью : дать новое имя
const {
  name: restaurantName,
  openingHours: hours,
  categories: tags
} = restaurant;
console.log(restaurantName, hours, tags); // сюда помещаем переменные которе только что назвали 
//Значения остались такими же, но мы дали им новые имена переменных. Которые снова будут безмерно(immensely) полезны, ПРИ ОБРАЩЕНИИ С ДАННЫМИ 3-Х ЛИЦ





// Другая полезная особенность для того, когда мы ОБРАЩАЕМСЯ С АНЫМИ 3 ЛЮДЬМИ КАК ТУТ
//Так как объекты которые мы получили откуда-то еще, дл например от API call,как только что было до этого . Это может быть действительно полезно иметь значения по умолчанию для случая которому мы пробуем прописать свойство, которое не существует в данном объекте . Поэтому обычно мы получаем undefined(неопределенное)
//Для примера если мы пробуем сказать restaurant.menu  тут будет undefined,  потому что в объекте нет такого свойства menu 
// В таких случаях мы можем установить значение по умолчанию, так же как и в массивах

//Default values

//если у menu не будет по умолчанию [] ,  то по оно будет undefined
const {
  menu = [], starterMenu: starters = []
} = restaurant;
console.log(menu, starters); // То есть так как menu не было найдено, то дефолтное значение примет пустой массив [], и в другую переменную starters запишется массив содержащийся в свойстве starterMenu
//ЭТО ОЧЕНЬ ПОЛЕЗНО КОГДА У НАС НЕТ ДАННЫХ КОТОТРЫЕ ЗАХАРКОЖЕНЫЕ КАК У НАС СВЕРХУ. НО В РЕАЛЬНОМ МИРЕ МЫ ОБЫЧНО ПОЛУЧАЕТ ДАННЫ ОТКУДА ТО ЕЩЕ. И ТОГДА МЫ МОЖЕМ НЕ ВСЕГДА ЗНАТЬ, КАК ИМЕННО ДАННЫЕ ВЫГЯЛДИТ(КАКИМИ ОНИ БУДУТ). ПОЭТОМУ ПОЛЕЗНО СТАВИТЬ ИМ ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ, КАК ЗДЕСЬ


//Следущим шаг надо поговорить о mutating(изменяющихся) variables ghb  деструктуризации (распаковки) объектов. Мы это делали с массивами, когда меняли(переключали) переменные [main,secondary] = [secondary,main]
//Но с объектами это работает немного иначе

//Mutating cariables
let ab = 111;
let bb = 999;
const obj = {ab: 23,bb: 7,cb: 14};

//{ab,bb} = obj; // тут будет SyntaxError:unexpectes token '=' Прчиной данной ошибки будет {ab,bb} круглые скобки слева, так как js ожидает блок кода. И так мы не можем ничего прописать(assign) для блока кода, как мы сделали здесь ошибку {ab,bb} = obj; знаком равно(=), после того как мы получили эту ошибку unexpectes token '='

// Решением данной ошибки будет завернуть все это в скобки 
({ab,bb} = obj); 
console.log(ab,bb); // Теперь правильно отобразятся две переменные 23 и 7



// Nested objects
//Теперь поговорим о nested objects (гнездрованных(то внутри другого )) так как мы делали и с массивами
//Допустим мы готим создать две переменные open and close  И они должны содержать часы открытия и закрытия ресторана для friday(пятницы)
// Как мы видим Opening houes является объектом(внутри обекта restaurant). И в этом объекте у нас есть другой объект . То есть этот объект fri находуится внутри объекта openingHours, который тоже находится внутри объекта restaurant 

//const {fri} = openingHours;
//console.log(fri); // выведится объект fri содержащий два объекта -  open:11 , close:23 

// Но мы хотим переменные одну для open и другую для close.. И вот как это будет работать. Мы знаем что fri - является объектом и теперь мы можем дальше деструктуризировать(распаковывать) объект использую такой syntax написаанный ниже

// Также мы можем переименовать переменные 
const {fri: {open: t,close: g}} = openingHours;
console.log(t,g); // выведится 11 для переменной t и 23 которое поместится в переменную g
//Необязательно это запоминать, но когда это понадобится можно будет посмотреть это видео 


//Destructuring Arrays

//Деструктурирующее присваивание

//Деструктуризация (destructuring) – синтаксическая возможность "раскладывать" элементы массива (и не только) в отдельные константы или переменные. Деструктуризация относится к необязательным, но очень приятным возможностям языка.

//Синтаксис деструктурирующего присваивания в выражениях JavaScript позволяет извлекать данные из массивов или объектов при помощи синтаксиса, подобного объявлению массива или литералов в объекте.

const arr = [2, 3, 4];
const a = arr[0];
const b = arr[1];
const c = arr[2];


//Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.

// Здесь хоть и махоже на массив  const [x,y,z], но на самом деле это массивом не является. Это просто деструктуризация assigment 
// Когда js виидит это на левой стороне знака равно, он значет что это должно быть деструктуризированно 
//Теперь, когда мы делаем это(деструктуризацию) надо не забывать также объявлять(declare) переменные используя const

const [x, y, z] = arr; // Мы применили здесь деструктуризацию этого массива 
console.log(x, y, z);

// Несмотря на то(Even though), что мы сделали деструктуризацию, которая звучит как-то отвелкающе
// Оригинальный массик конечно никак не ззатронут(affected) 
console.log(arr);
// Мы не сломали выше массив, мы только деструктуризировали, так что мы распаковали(разложили) его 


// Возьмем некоторые элементы из объекта restaurant 

//Допустим нам нужно 1 и 3 элеммент массива, и чтобы нам их распокавать нам нужно просто оставить дыру в деструктурирующим операторе const [first, ,second]. 
// Второй элемент будет пропущен и second - станет 3 ем элементом

const [first, , second] = restaurant.categories; // мы взли два первых элемента массива и деструктуризировали его распоковав эти элементы
console.log(first, second); // Italian Pizzeria // Полсе появления дыры отобразятся Italian Vegeterian 

// И вот так(And so like this) нам не надо создават переменые для всех вещей, которые нам могут даже нам не понадобиться  




// Assigment to const variable - Значит что ошибк изза того что мы переменную const хотим изменить, а надо для этого использовать переменную let
let [main, , secondary] = restaurant.categories;
console.log(main, secondary);
// Допустим мы хотим  поменять места две переменные без деструктуризации нам придется делать вот так 
// СОздать временную переменную, чтобы поменять им значения, потому что без временной переменной они просто перезапишутся

// Swithing variables
//const temp = main;
//main = secondary;
//secondary = temp;
//console.log(main, secondary); // Теперь они поменялись местами


// Но с помощью деструктуризации мы можем сделать это намного проще 
// Сначала нам надо создатьновый массив с двумя переменными, которые будут inverted(перевернуыми) и затем мы можем просто distract(распоковать, разложить ) их
[main, secondary] = [secondary, main]; // Здесь мы не используем let or const так как мы просто перезаписываем значения этих двух переменных, как мы делали выше
// Но сейчас нам не нужна временная переменная по середине
console.log(main, secondary); // Vegeterian Italian 




// Другой способ использования деструктуризации это - то то мы можем иметь функцию, возвращающую массив и тогда мы можем немендлено distract(разложить) этот результат в разные переменные. Таким образом, это в основном нам позволяет возвращать несколько (multiple) значений from function (из функции)



//Поробуем это написав функцию возвращающею food ORDER фУНКЦИЯ НАПИСАНА ВВЕРХУ В ОБЪЕКТЕ РЕСТОРАН 

// Receive 2 returns values from a function 

console.log(restaurant.order(2, 0)); // Мы получим массив ['Garlcic Bread', 'Pizza'] // То есть мы взяли элемент под индексом 2 из 1го масива, и элемент под нулевым индексом из второго массива
//Теперь мы модем распоковать(distract) эти значения
const [starter, mainCourse] = restaurant.order(2, 0);
console.log(starter, mainCourse); // получили отдельные переменные со своими значениями Garlic Bread и Pizza



// Nested destructuring
// Что будет если у нас будет гнездированный(nested) один внутри другого  массив 
// То есть один массив внтури другого(nested)
const nested = [2, 4, [5, 6]];
//Получим с помощью distract( распаковки ) 2 и другой массив [5,6]
const [i, , j] = nested;
console.log(i, j); // Выведятся ээти две переменные со значениями 2 и [5,6]

//Но если мы захотим чтобы у всех были индивидуальные значение. Тогда мы должны применить диструктуризацию внутри диструктуризации(распоковку снутри распоковки)

const [q, , [w, e]] = nested;
console.log(q, w, e); // Получим 2 потом 5 и для переменной e - 6




// Default values 

// Еще одна особеность(фича)/ Так мы можем также установить дефолтные(по умолчанию) значения, для переменных, когда мы извлекаем их/ Это будет очень полезно в ситуации когжа мы не знаем длину массива.Это иногда случается в реальном мире приложений

//Так если у нас есть массив, который короче чем мы думаем. Тогда мы можем попробовать расспаковать(unpack) массив в позиции, которые даже не сущесвтуют 

const [p = 1, o = 1, u = 2] = [8, 9]; // То есть не зная длину массива справа, мы напишем, что если будет больше элементов деструктуризировано(распаковано) то элементы, которым не хватило место примут значения = 1(если напишем 2, то будет 2), которое мы установили, по умолчанию
console.log(p, o, u);
// Это бывает полезным когда мы получаем данны от API
